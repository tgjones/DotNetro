using System.Buffers.Binary;
using System.Diagnostics;

using DotNetro.Compiler.TypeSystem;

namespace DotNetro.Compiler.CodeGen;

internal abstract class M6502CodeGenerator(TextWriter output)
    : CodeGenerator(output)
{
    protected const string ArgsLabel = "args";

    public override int PointerSize { get; } = 2;

    private enum BuiltInMethod
    {
        AddInt16,
        AddInt32,
        CltInt32,
    }

    private readonly HashSet<BuiltInMethod> _usedBuiltInMethods = [];

    public override void WriteHeader()
    {
        Output.WriteLine("; Generated by DotNetro");
        Output.WriteLine();

        WriteSystemConstants();

        Output.WriteLine($"scratch = $60");
        Output.WriteLine($"{ArgsLabel} = $70");
        Output.WriteLine();
        Output.WriteLine($"* = $2000");
        Output.WriteLine();
    }

    protected virtual void WriteSystemConstants() { }

    public override void WriteEntryPoint(string entryPointMethodName)
    {
        WriteLabel("start");

        WriteStartupCode();

        Output.WriteLine("    ; Initialize stack");
        Output.WriteLine("    LDX #0");
        Output.WriteLine();
        Output.WriteLine("    ; Call static constructors");
        Output.WriteLine("    JSR CallStaticConstructors");
        Output.WriteLine();
        Output.WriteLine("    ; Call main function");
        Output.WriteLine($"    JSR {entryPointMethodName}");
        Output.WriteLine();
        Output.WriteLine("    RTS");
        Output.WriteLine();
    }

    protected virtual void WriteStartupCode() { }

    public override void WriteStringConstant(string name, string value)
    {
        WriteLabel(name);
        Output.WriteLine($"    .cstring \"{value}\", 13");
    }

    public override void WriteStaticField(EcmaField field)
    {
        WriteLabel(GetStaticFieldName(field));
        Output.WriteLine($"    .fill {field.Type.Size},0");
    }

    public override void WriteFooter(ReadOnlySpan<EcmaMethod> staticConstructors)
    {
        foreach (var builtInMethod in _usedBuiltInMethods)
        {
            switch (builtInMethod)
            {
                case BuiltInMethod.AddInt16:
                    CompileAddInt16();
                    break;

                case BuiltInMethod.AddInt32:
                    CompileAddInt32();
                    break;

                case BuiltInMethod.CltInt32:
                    CompileCltInt32();
                    break;

                default:
                    throw new NotImplementedException();
            }

            Output.WriteLine();
        }

        WriteLabel("CallStaticConstructors");
        foreach (var staticConstructor in staticConstructors)
        {
            Output.WriteLine($"    JSR {staticConstructor.UniqueName}");
        }
        Output.WriteLine("    RTS");
        Output.WriteLine();
    }

    private void CompileAddInt16()
    {
        WriteLabel("AddInt16");
        Output.WriteLine("    CLC");
        Output.WriteLine("    LDA $FE,X ; Subtract 2 from current stack pointer");
        Output.WriteLine("    ADC $FC,X ; Subtract 4 from current stack pointer");
        Output.WriteLine("    STA $FC,X");
        Output.WriteLine("    LDA $FF,X ; Subtract 1 from current stack pointer");
        Output.WriteLine("    ADC $FD,X ; Subtract 3 from current stack pointer");
        Output.WriteLine("    STA $FD,X");
        Output.WriteLine("    DEX:DEX");
        Output.WriteLine("    RTS");
    }

    private void CompileAddInt32()
    {
        WriteLabel("AddInt32");
        Output.WriteLine("    CLC");
        Output.WriteLine("    LDA $FC,X ; Subtract 4 from current stack pointer");
        Output.WriteLine("    ADC $F8,X ; Subtract 8 from current stack pointer");
        Output.WriteLine("    STA $F8,X");
        Output.WriteLine("    LDA $FD,X ; Subtract 3 from current stack pointer");
        Output.WriteLine("    ADC $F9,X ; Subtract 7 from current stack pointer");
        Output.WriteLine("    STA $F9,X");
        Output.WriteLine("    LDA $FE,X ; Subtract 2 from current stack pointer");
        Output.WriteLine("    ADC $FA,X ; Subtract 6 from current stack pointer");
        Output.WriteLine("    STA $FA,X");
        Output.WriteLine("    LDA $FF,X ; Subtract 1 from current stack pointer");
        Output.WriteLine("    ADC $FB,X ; Subtract 5 from current stack pointer");
        Output.WriteLine("    STA $FB,X");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    RTS");
    }

    private void CompileCltInt32()
    {
        WriteLabel("CltInt32");
        BeginScopeBlock();
        Output.WriteLine("    LDA $F8,X");
        Output.WriteLine("    CMP $FC,X");
        Output.WriteLine("    LDA $F9,X");
        Output.WriteLine("    SBC $FD,X");
        Output.WriteLine("    LDA $FA,X");
        Output.WriteLine("    SBC $FE,X");
        Output.WriteLine("    LDA $FB,X");
        Output.WriteLine("    SBC $FF,X");
        Output.WriteLine("    BVC mylabel");
        Output.WriteLine("    EOR #$80");
        WriteLabel("mylabel");
        Output.WriteLine("    BMI lessthan");
        Output.WriteLine("    LDA #0");
        Output.WriteLine("    JMP finish");
        WriteLabel("lessthan");
        Output.WriteLine("    LDA #1");
        WriteLabel("finish");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    STA 0,X");
        Output.WriteLine("    INX");
        Output.WriteLine("    RTS");
        EndScopeBlock();
    }

    protected void WritePushX()
    {
        Output.WriteLine("    TXA ; Save X");
        Output.WriteLine("    PHA");
    }

    protected void WritePopX()
    {
        Output.WriteLine("    PLA ; Restore X");
        Output.WriteLine("    TAX");
    }

    public override void WriteMethodStart(string name)
    {
        WriteLabel(name);
        BeginScopeBlock();
    }

    public override void WriteMethodEnd()
    {
        EndScopeBlock();
        Output.WriteLine();
    }

    public override void WriteLabel(string label)
    {
        Output.WriteLine($"{label}:");
    }

    private void BeginScopeBlock()
    {
        Output.WriteLine($"    .block");
    }

    private void EndScopeBlock()
    {
        Output.WriteLine($"    .endblock");
    }

    public override void WriteComment(string text)
    {
        Output.WriteLine($"    ; {text}");
    }

    public override void WriteAddInt32()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.AddInt32);
        Output.WriteLine("    JSR AddInt32");
    }

    public override void WriteAddIntPtr()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.AddInt16);
        Output.WriteLine("    JSR AddInt16");
    }

    public override void WriteBr(string label)
    {
        Output.WriteLine($"    JMP {label}");
    }

    public override void WriteBrtrue(TypeDescription stackObjectType, string label)
    {
        BeginScopeBlock();

        for (var i = 0; i < stackObjectType.Size; i++)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    BNE dojump");
        }

        Output.WriteLine($"    JMP after");

        // Would prefer to do direct BNE but it might be further than 128 bytes away.
        WriteLabel("dojump");
        Output.WriteLine($"    JMP {label}");

        WriteLabel("after");

        EndScopeBlock();
    }

    public override void WriteCall(EcmaMethod caller, EcmaMethod callee)
    {
        WritePushArgsAndLocals(caller);

        WritePopToMemory(ArgsLabel, callee.ParametersSize);

        Output.WriteLine($"    JSR {callee.UniqueName}");

        WritePopArgsAndLocals(caller);
    }

    public override void WriteCltInt32()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.CltInt32);
        Output.WriteLine("    JSR CltInt32");
    }

    public override void WriteConviInt32()
    {
        Output.WriteLine("DEX:DEX");
    }

    public override void WriteDup(TypeDescription type)
    {
        var offset = (sbyte)-type.Size;

        for (var i = 0; i < type.Size; i++)
        {
            Output.WriteLine($"    LDA ${offset:X2},X ; Subtract type size from current stack pointer");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    public override void WriteInitobj(TypeDescription type)
    {
        // Address is on stack. Copy to scratch area.
        WritePopToMemory("scratch", PointerSize);

        Output.WriteLine($"    LDA #0");
        for (var i = 0; i < type.InstanceSize; i++)
        {
            Output.WriteLine($"    LDY #{i}"); // TODO: Use INY
            Output.WriteLine($"    STA (scratch),Y");
        }
    }

    public override void WriteLdarg(Parameter parameter)
    {
        WritePushFromMemory($"{ArgsLabel}+{parameter.Offset}", parameter.Type.Size);
    }

    public override void WriteLdcI4(int value)
    {
        Span<byte> bytes = stackalloc byte[4];
        BinaryPrimitives.WriteInt32LittleEndian(bytes, value);

        WritePushConstant(bytes);
    }

    public override void WriteLdfld(TypeDescription objectType, EcmaField field)
    {
        // Top of stack is either address of object, or actual value-type instance.

        WritePopToMemory("scratch", objectType.Size);

        if (objectType.IsPointerLike)
        {
            for (var i = 0; i < field.Type.Size; i++)
            {
                Output.WriteLine($"    LDY #{field.Offset + i}");
                Output.WriteLine($"    LDA (scratch),Y");
                Output.WriteLine($"    STA 0,X");
                Output.WriteLine($"    INX");
            }
        }
        else
        {
            Debug.Assert(objectType is EcmaType { IsValueType: true });
            WritePushFromMemory($"scratch+{field.Offset}", field.Type.Size);
        }
    }

    public override void WriteLdloc(LocalVariable local)
    {
        WritePushFromMemory(GetLocalVariableOffsetAddress(local), local.Type.Size);
    }

    public override void WriteLdloca(LocalVariable local)
    {
        Output.WriteLine($"    LDA #<{GetLocalVariableOffsetAddress(local)}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #>{GetLocalVariableOffsetAddress(local)}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteLdsfld(EcmaField field)
    {
        WritePushFromMemory(GetStaticFieldName(field), field.Type.Size);
    }

    public override void WriteLdstr(string name)
    {
        Output.WriteLine($"    LDA #<{name}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #>{name}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteNewobj(EcmaMethod caller, EcmaMethod constructor, EcmaMethod allocMethod)
    {
        WritePushArgsAndLocals(caller);

        // Call alloc method with size parameter.
        {
            Span<byte> bytes = stackalloc byte[PointerSize];
            BinaryPrimitives.WriteUInt16LittleEndian(bytes, (ushort)constructor.DeclaringType.InstanceSize);
            for (var i = 0; i < PointerSize; i++)
            {
                Output.WriteLine($"    LDA #${bytes[i]:X2}");
                Output.WriteLine($"    STA {ArgsLabel}+{i}");
            }
        }
        Output.WriteLine($"    JSR {allocMethod.UniqueName}");

        // Current top of stack is address of memory allocated by alloc method.
        // We save it to the hardware stack, because this will be the result of newobj.
        // We also want to copy it into args as the first argument to the constructor.
        for (var i = PointerSize - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {ArgsLabel}+{i}");
            Output.WriteLine($"    PHA");
        }

        // Push constructor args (not including "this") to stack.
        WritePopToMemory($"{ArgsLabel}+{PointerSize}", constructor.ParametersSize - PointerSize);

        // Call constructor.
        Output.WriteLine($"    JSR {constructor.UniqueName}");

        // Restore the address of the new object to the top of the stack.
        for (var i = 0; i < PointerSize; i++)
        {
            Output.WriteLine($"    PLA");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }

        WritePopArgsAndLocals(caller);
    }

    public override void WriteRet()
    {
        Output.WriteLine("    RTS");
    }

    public override void WriteStfld(EcmaField field)
    {
        // Value is at top of stack.
        // Underneath that is address of object.

        var addressLo = (byte)(0 - field.Type.Size - PointerSize);
        var addressHi = (byte)(0 - field.Type.Size - PointerSize + 1);

        Output.WriteLine($"    LDA ${addressLo:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA scratch+0");
        Output.WriteLine($"    LDA ${addressHi:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA scratch+1");

        for (var i = field.Type.Size - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    LDY #{field.Offset + i}");
            Output.WriteLine($"    STA (scratch),Y");
        }

        for (var i = 0; i < PointerSize; i++)
        {
            Output.WriteLine($"    DEX");
        }
    }

    public override void WriteStloc(LocalVariable local)
    {
        WritePopToMemory(GetLocalVariableOffsetAddress(local), local.Type.Size);
    }

    public override void WriteStsfld(EcmaField field)
    {
        WritePopToMemory(GetStaticFieldName(field), field.Type.Size);
    }

    private void WritePushFromMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = 0; i < sizeInBytes; i++)
        {
            Output.WriteLine($"    LDA {baseAddress}+{i}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    protected void WritePushConstant(ReadOnlySpan<byte> bytes)
    {
        foreach (byte value in bytes)
        {
            Output.WriteLine($"    LDA #{value}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    private void WritePopToMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = sizeInBytes - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {baseAddress}+{i}");
        }
    }

    private void WritePushArgsAndLocals(EcmaMethod currentMethod)
    {
        // Push current method's args+locals to hardware stack.
        for (var i = 0; i < currentMethod.ParametersSize + currentMethod.LocalsSize; i++)
        {
            Output.WriteLine($"    LDA {ArgsLabel}+{i}");
            Output.WriteLine($"    PHA");
        }
    }

    private void WritePopArgsAndLocals(EcmaMethod currentMethod)
    {
        // Pop current method's args+locals from hardware stack.
        for (var i = currentMethod.ParametersSize + currentMethod.LocalsSize - 1; i >= 0; i--)
        {
            Output.WriteLine($"    PLA");
            Output.WriteLine($"    STA {ArgsLabel}+{i}");

        }
    }

        // Locals are stored immediately above args.
    private static string GetLocalVariableOffsetAddress(LocalVariable local) => 
        $"{ArgsLabel}+{local.Parent.ParametersSize + local.Offset}";

    private static string GetStaticFieldName(EcmaField field) => $"{field.Owner.EncodedName}_{field.Name}";
}
