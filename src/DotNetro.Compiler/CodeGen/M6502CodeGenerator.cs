using System.Buffers.Binary;

using DotNetro.Compiler.TypeSystem;

namespace DotNetro.Compiler.CodeGen;

internal abstract class M6502CodeGenerator(StreamWriter output)
    : CodeGenerator(output)
{
    public override int PointerSize { get; } = 2;

    private enum BuiltInMethod
    {
        AddInt32,
    }

    private readonly HashSet<BuiltInMethod> _usedBuiltInMethods = [];

    public override void WriteHeader()
    {
        Output.WriteLine("; Generated by DotNetro");
        Output.WriteLine("");
        Output.WriteLine("oswrch = &FFEE");
        Output.WriteLine("osasci = &FFE3");
        Output.WriteLine("osword = &FFF1");
        Output.WriteLine();
        Output.WriteLine("scratch = &60");
        Output.WriteLine("args = &70");
        Output.WriteLine("locals = &90");
        Output.WriteLine();
        Output.WriteLine("ORG &2000");
        Output.WriteLine();
    }

    public override void WriteEntryPoint(string entryPointMethodName)
    {
        Output.WriteLine(".start");

        WriteStartupCode();

        Output.WriteLine("    ; Initialize stack");
        Output.WriteLine("    LDX #0");
        Output.WriteLine();
        Output.WriteLine("    ; Call main function");
        Output.WriteLine($"    JSR {entryPointMethodName}");
        Output.WriteLine();
        Output.WriteLine("    RTS");
        Output.WriteLine();
    }

    protected virtual void WriteStartupCode() { }

    public override void WriteStringConstant(string name, string value)
    {
        Output.WriteLine($".{name} EQUS \"{value}\", 13, 0");
    }

    public override void WriteFooter()
    {
        foreach (var builtInMethod in _usedBuiltInMethods)
        {
            switch (builtInMethod)
            {
                case BuiltInMethod.AddInt32:
                    CompileAddInt32();
                    break;

                default:
                    throw new NotImplementedException();
            }

            Output.WriteLine();
        }

        Output.WriteLine(".end");
        Output.WriteLine("");
        Output.WriteLine("SAVE \"MyCode\", start, end");
    }

    private void CompileAddInt32()
    {
        Output.WriteLine(".AddInt32");
        Output.WriteLine("    CLC");
        Output.WriteLine("    LDA $FC,X ; Subtract 4 from current stack pointer");
        Output.WriteLine("    ADC $F8,X ; Subtract 8 from current stack pointer");
        Output.WriteLine("    STA $F8,X");
        Output.WriteLine("    LDA $FD,X ; Subtract 3 from current stack pointer");
        Output.WriteLine("    ADC $F9,X ; Subtract 7 from current stack pointer");
        Output.WriteLine("    STA $F9,X");
        Output.WriteLine("    LDA $FE,X ; Subtract 2 from current stack pointer");
        Output.WriteLine("    ADC $FA,X ; Subtract 6 from current stack pointer");
        Output.WriteLine("    STA $FA,X");
        Output.WriteLine("    LDA $FF,X ; Subtract 1 from current stack pointer");
        Output.WriteLine("    ADC $FB,X ; Subtract 5 from current stack pointer");
        Output.WriteLine("    STA $FB,X");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    RTS");
    }

    protected void WritePushX()
    {
        Output.WriteLine("    TXA ; Save X");
        Output.WriteLine("    PHA");
    }

    protected void WritePopX()
    {
        Output.WriteLine("    PLA ; Restore X");
        Output.WriteLine("    TAX");
    }

    public override void WriteMethodStart(string name)
    {
        Output.WriteLine($".{name}");
        Output.WriteLine("{");
    }

    public override void WriteMethodEnd()
    {
        Output.WriteLine("}");
        Output.WriteLine();
    }

    public override void WriteLabel(string label)
    {
        Output.WriteLine($".{label}");
    }

    public override void WriteComment(string text)
    {
        Output.WriteLine($"    ; {text}");
    }

    public override void WriteAdd()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.AddInt32);
        Output.WriteLine("    JSR AddInt32");
    }

    public override void WriteBr(string label)
    {
        Output.WriteLine($"    JMP {label}");
    }

    public override void WriteCall(EcmaMethod methodToCall)
    {
        WritePopToMemory("args", methodToCall.MethodSignature.ParameterTypes.Sum(x => x.Size));

        Output.WriteLine($"    JSR {methodToCall.UniqueName}");
    }

    public override void WriteInitobj(TypeDescription type)
    {
        // Address is on stack. Copy to scratch area.
        WritePopToMemory("scratch", PointerSize);

        Output.WriteLine($"    LDA #0");
        for (var i = 0; i < type.Size; i++)
        {
            Output.WriteLine($"    LDY #{i}"); // TODO: Use INY
            Output.WriteLine($"    STA (scratch),Y");
        }
    }

    public override void WriteLdarg(Parameter parameter)
    {
        WritePushFromMemory($"args+{parameter.Offset}", parameter.Type.Size);
    }

    public override void WriteLdcI4(int value)
    {
        Span<byte> bytes = stackalloc byte[4];
        BinaryPrimitives.WriteInt32LittleEndian(bytes, value);

        WritePushConstant(bytes);
    }

    public override void WriteLdfld(TypeDescription objectType, EcmaField field)
    {
        // Value is at top of stack.
        // Underneath that is either address of object, or actual value-type instance.

        WritePopToMemory("scratch", objectType.Size);

        switch (objectType)
        {
            case PointerType:
                for (var i = 0; i < field.Type.Size; i++)
                {
                    Output.WriteLine($"    LDY #{field.Offset + i}");
                    Output.WriteLine($"    LDA (scratch),Y");
                    Output.WriteLine($"    STA 0,X");
                    Output.WriteLine($"    INX");
                }
                break;

            case EcmaType:
                WritePushFromMemory($"scratch+{field.Offset}", field.Type.Size);
                break;

            default:
                throw new InvalidOperationException();
        }
    }

    public override void WriteLdloc(LocalVariable local)
    {
        WritePushFromMemory($"locals+{local.Offset}", local.Type.Size);
    }

    public override void WriteLdloca(LocalVariable local)
    {
        Output.WriteLine($"    LDA #LO(locals+{local.Offset})");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #HI(locals+{local.Offset})");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteLdstr(string name)
    {
        Output.WriteLine($"    LDA #LO({name})");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #HI({name})");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteRet()
    {
        Output.WriteLine("    RTS");
    }

    public override void WriteStfld(EcmaField field)
    {
        // Value is at top of stack.
        // Underneath that is address of object.

        var addressLo = (byte)(0 - field.Type.Size - PointerSize);
        var addressHi = (byte)(0 - field.Type.Size - PointerSize + 1);

        Output.WriteLine($"    LDA ${addressLo:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA scratch+0");
        Output.WriteLine($"    LDA ${addressHi:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA scratch+1");

        for (var i = field.Type.Size - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    LDY #{field.Offset + i}");
            Output.WriteLine($"    STA (scratch),Y");
        }

        for (var i = 0; i < PointerSize; i++)
        {
            Output.WriteLine($"    DEX");
        }
    }

    public override void WriteStloc(LocalVariable local)
    {
        WritePopToMemory($"locals+{local.Offset}", local.Type.Size);
    }

    private void WritePushFromMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = 0; i < sizeInBytes; i++)
        {
            Output.WriteLine($"    LDA {baseAddress}+{i}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    protected void WritePushConstant(ReadOnlySpan<byte> bytes)
    {
        foreach (byte value in bytes)
        {
            Output.WriteLine($"    LDA #{value}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    private void WritePopToMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = sizeInBytes - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {baseAddress}+{i}");
        }
    }
}
