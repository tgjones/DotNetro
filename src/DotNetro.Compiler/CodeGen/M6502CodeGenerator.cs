using System.Buffers.Binary;
using System.Diagnostics;
using System.Net;

using DotNetro.Compiler.TypeSystem;

using static System.Formats.Asn1.AsnWriter;

namespace DotNetro.Compiler.CodeGen;

internal abstract class M6502CodeGenerator(TextWriter output)
    : CodeGenerator(output)
{
    protected const string ScratchLabel = "scratch";
    protected const string ArgsLabel = "args";

    public override int PointerSize { get; } = 2;

    private enum BuiltInMethod
    {
        AddInt16,
        AddInt32,
        Callvirt,
        CltInt32,
    }

    private readonly HashSet<BuiltInMethod> _usedBuiltInMethods = [];

    public override void WriteHeader()
    {
        Output.WriteLine("; Generated by DotNetro");
        Output.WriteLine();

        WriteSystemConstants();

        Output.WriteLine($"{ScratchLabel} = $60");
        Output.WriteLine($"{ArgsLabel} = $70");
        Output.WriteLine();
        Output.WriteLine($"* = $2000");
        Output.WriteLine();
    }

    protected virtual void WriteSystemConstants() { }

    public override void WriteEntryPoint(string entryPointMethodName)
    {
        WriteLabel("start");

        WriteStartupCode();

        Output.WriteLine("    ; Initialize evaluation stack");
        Output.WriteLine("    LDX #0");
        Output.WriteLine();
        Output.WriteLine("    ; Initialize args+locals stack");
        Output.WriteLine("    LDY #0");
        Output.WriteLine();
        Output.WriteLine("    ; Call static constructors");
        Output.WriteLine("    JSR CallStaticConstructors");
        Output.WriteLine();
        Output.WriteLine("    ; Call main function");
        Output.WriteLine($"    JSR {entryPointMethodName}");
        Output.WriteLine();
        Output.WriteLine("    RTS");
        Output.WriteLine();
    }

    protected virtual void WriteStartupCode() { }

    public override void WriteStringConstant(string name, string value)
    {
        WriteLabel(name);
        Output.WriteLine($"    .cstring \"{value}\", 13");
        Output.WriteLine();
    }

    public override void WriteStaticField(EcmaField field)
    {
        WriteLabel(GetStaticFieldName(field));
        Output.WriteLine($"    .fill {field.Type.Size},0");
        Output.WriteLine();
    }

    public override void WriteFooter(ReadOnlySpan<EcmaMethod> staticConstructors)
    {
        foreach (var builtInMethod in _usedBuiltInMethods)
        {
            switch (builtInMethod)
            {
                case BuiltInMethod.AddInt16:
                    CompileAddInt16();
                    break;

                case BuiltInMethod.AddInt32:
                    CompileAddInt32();
                    break;

                case BuiltInMethod.Callvirt:
                    CompileCallvirt();
                    break;

                case BuiltInMethod.CltInt32:
                    CompileCltInt32();
                    break;

                default:
                    throw new NotImplementedException();
            }

            Output.WriteLine();
        }

        WriteLabel("CallStaticConstructors");
        foreach (var staticConstructor in staticConstructors)
        {
            Output.WriteLine($"    JSR {staticConstructor.UniqueName}");
        }
        Output.WriteLine("    RTS");
        Output.WriteLine();
    }

    private void CompileAddInt16()
    {
        WriteLabel("AddInt16");
        Output.WriteLine("    CLC");
        Output.WriteLine("    LDA $FE,X ; Subtract 2 from current stack pointer");
        Output.WriteLine("    ADC $FC,X ; Subtract 4 from current stack pointer");
        Output.WriteLine("    STA $FC,X");
        Output.WriteLine("    LDA $FF,X ; Subtract 1 from current stack pointer");
        Output.WriteLine("    ADC $FD,X ; Subtract 3 from current stack pointer");
        Output.WriteLine("    STA $FD,X");
        Output.WriteLine("    DEX:DEX");
        Output.WriteLine("    RTS");
    }

    private void CompileAddInt32()
    {
        WriteLabel("AddInt32");
        Output.WriteLine("    CLC");
        Output.WriteLine("    LDA $FC,X ; Subtract 4 from current stack pointer");
        Output.WriteLine("    ADC $F8,X ; Subtract 8 from current stack pointer");
        Output.WriteLine("    STA $F8,X");
        Output.WriteLine("    LDA $FD,X ; Subtract 3 from current stack pointer");
        Output.WriteLine("    ADC $F9,X ; Subtract 7 from current stack pointer");
        Output.WriteLine("    STA $F9,X");
        Output.WriteLine("    LDA $FE,X ; Subtract 2 from current stack pointer");
        Output.WriteLine("    ADC $FA,X ; Subtract 6 from current stack pointer");
        Output.WriteLine("    STA $FA,X");
        Output.WriteLine("    LDA $FF,X ; Subtract 1 from current stack pointer");
        Output.WriteLine("    ADC $FB,X ; Subtract 5 from current stack pointer");
        Output.WriteLine("    STA $FB,X");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    RTS");
    }

    private void CompileCltInt32()
    {
        WriteLabel("CltInt32");
        BeginScopeBlock();
        Output.WriteLine("    LDA $F8,X");
        Output.WriteLine("    CMP $FC,X");
        Output.WriteLine("    LDA $F9,X");
        Output.WriteLine("    SBC $FD,X");
        Output.WriteLine("    LDA $FA,X");
        Output.WriteLine("    SBC $FE,X");
        Output.WriteLine("    LDA $FB,X");
        Output.WriteLine("    SBC $FF,X");
        Output.WriteLine("    BVC mylabel");
        Output.WriteLine("    EOR #$80");
        WriteLabel("mylabel");
        Output.WriteLine("    BMI lessthan");
        Output.WriteLine("    LDA #0");
        Output.WriteLine("    JMP finish");
        WriteLabel("lessthan");
        Output.WriteLine("    LDA #1");
        WriteLabel("finish");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    DEX:DEX:DEX:DEX");
        Output.WriteLine("    STA 0,X");
        Output.WriteLine("    INX");
        Output.WriteLine("    RTS");
        EndScopeBlock();
    }

    private void CompileCallvirt()
    {
        WriteLabel("Callvirt");
        BeginScopeBlock();
        Output.WriteLine($"    LDA scratch+1");
        Output.WriteLine($"    PHA");
        Output.WriteLine($"    LDA scratch+0");
        Output.WriteLine($"    PHA");
        Output.WriteLine($"    RTS ; Actually JMP to subroutine address on stack");
        EndScopeBlock();
    }

    public override void WriteVtables(ReadOnlySpan<Vtable> vtables)
    {
        var uniqueSlotLabels = new SortedDictionary<string, byte>();

        foreach (var vtable in vtables)
        {
            WriteLabel(vtable.Name);

            foreach (var slot in vtable.Slots)
            {
                Output.WriteLine($"    .word {slot.Method.UniqueName}-1");

                uniqueSlotLabels[slot.Label] = slot.Index;
            }

            Output.WriteLine();
        }

        foreach (var (slotLabel, slotIndex) in uniqueSlotLabels)
        {
            Output.WriteLine($"{slotLabel} = {slotIndex*2}");
        }

        Output.WriteLine();
    }

    protected void WritePushX()
    {
        Output.WriteLine("    TXA ; Save X");
        Output.WriteLine("    PHA");
    }

    protected void WritePopX()
    {
        Output.WriteLine("    PLA ; Restore X");
        Output.WriteLine("    TAX");
    }

    public override void WriteMethodStart(string name)
    {
        WriteLabel(name);
        BeginScopeBlock();
    }

    public override void WriteMethodEnd()
    {
        EndScopeBlock();
        Output.WriteLine();
    }

    public override void WriteLabel(string label)
    {
        Output.WriteLine($"{label}:");
    }

    private void BeginScopeBlock()
    {
        Output.WriteLine($"    .block");
    }

    private void EndScopeBlock()
    {
        Output.WriteLine($"    .endblock");
    }

    public override void WriteComment(string text)
    {
        Output.WriteLine($"    ; {text}");
    }

    public override void WriteAddInt32()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.AddInt32);
        Output.WriteLine("    JSR AddInt32");
    }

    public override void WriteAddIntPtr()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.AddInt16);
        Output.WriteLine("    JSR AddInt16");
    }

    public override void WriteBr(string label)
    {
        Output.WriteLine($"    JMP {label}");
    }

    public override void WriteBrtrue(TypeDescription stackObjectType, string label)
    {
        BeginScopeBlock();

        for (var i = 0; i < stackObjectType.Size; i++)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    BNE dojump");
        }

        Output.WriteLine($"    JMP after");

        // Would prefer to do direct BNE but it might be further than 128 bytes away.
        WriteLabel("dojump");
        Output.WriteLine($"    JMP {label}");

        WriteLabel("after");

        EndScopeBlock();
    }

    public override void WriteCall(EcmaMethod caller, EcmaMethod callee)
    {
        WritePushFrame(caller);

        WritePopToFrame(0, callee.ParametersSize);

        Output.WriteLine($"    JSR {callee.UniqueName}");

        WritePopFrame(caller);
    }

    public override void WriteCallvirt(EcmaMethod caller, EcmaMethod callee, string vtableSlotLabel)
    {
        _usedBuiltInMethods.Add(BuiltInMethod.Callvirt);

        WritePushFrame(caller);

        WritePopToFrame(0, callee.ParametersSize);

        Output.WriteLine($"    SEC ; Subtract 2 from `this` argument");
        Output.WriteLine($"    LDA {ArgsLabel}+0,Y");
        Output.WriteLine($"    SBC #2");
        Output.WriteLine($"    STA scratch+2");
        Output.WriteLine($"    LDA {ArgsLabel}+1,Y");
        Output.WriteLine($"    SBC #0");
        Output.WriteLine($"    STA scratch+3");
        Output.WriteLine($"    TYA");
        Output.WriteLine($"    PHA");
        Output.WriteLine($"    LDY #{vtableSlotLabel}+1 ; Read high address byte from vtable");
        Output.WriteLine($"    LDA (scratch+2),Y");
        Output.WriteLine($"    STA scratch+1");
        Output.WriteLine($"    LDY #{vtableSlotLabel}+0 ; Read low address byte from vtable");
        Output.WriteLine($"    LDA (scratch+2),Y");
        Output.WriteLine($"    STA scratch+0");
        Output.WriteLine($"    PLA");
        Output.WriteLine($"    TAY");
        Output.WriteLine($"    JSR Callvirt");

        WritePopFrame(caller);
    }

    public override void WriteCltInt32()
    {
        _usedBuiltInMethods.Add(BuiltInMethod.CltInt32);
        Output.WriteLine("    JSR CltInt32");
    }

    public override void WriteConviInt32()
    {
        Output.WriteLine("DEX:DEX");
    }

    public override void WriteDup(TypeDescription type)
    {
        var offset = (sbyte)-type.Size;

        for (var i = 0; i < type.Size; i++)
        {
            Output.WriteLine($"    LDA ${offset:X2},X ; Subtract type size from current stack pointer");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    public override void WriteInitobj(TypeDescription type)
    {
        // Address is on stack. Copy to scratch area.
        WritePopToMemory(ScratchLabel, PointerSize);

        WritePushY();

        Output.WriteLine($"    LDA #0");
        for (var i = 0; i < type.InstanceSize; i++)
        {
            Output.WriteLine($"    LDY #{i}"); // TODO: Use INY
            Output.WriteLine($"    STA ({ScratchLabel}),Y");
        }

        WritePopY();
    }

    public override void WriteLdarg(Parameter parameter)
    {
        WritePushFromFrame(parameter.Offset, parameter.Type.Size);
    }

    public override void WriteLdcI4(int value)
    {
        Span<byte> bytes = stackalloc byte[4];
        BinaryPrimitives.WriteInt32LittleEndian(bytes, value);

        WritePushConstant(bytes);
    }

    public override void WriteLdfld(TypeDescription objectType, EcmaField field)
    {
        // Top of stack is either address of object, or actual value-type instance.

        WritePopToMemory(ScratchLabel, objectType.Size);

        if (objectType.IsPointerLike)
        {
            WritePushY();
            for (var i = 0; i < field.Type.Size; i++)
            {
                Output.WriteLine($"    LDY #{field.Offset + i}");
                Output.WriteLine($"    LDA ({ScratchLabel}),Y");
                Output.WriteLine($"    STA 0,X");
                Output.WriteLine($"    INX");
            }
            WritePopY();
        }
        else
        {
            Debug.Assert(objectType is EcmaType { IsValueType: true });
            WritePushFromMemory($"{ScratchLabel}+{field.Offset}", field.Type.Size);
        }
    }

    public override void WriteLdloc(LocalVariable local)
    {
        WritePushFromFrame(local.Parent.ParametersSize + local.Offset, local.Type.Size);
    }

    public override void WriteLdloca(LocalVariable local)
    {
        // Need the lo and hi bytes of address of local variable.
        // Address is ArgsLabel + local.Parent.ParametersSize + local.Offset + Y.
        // For now we assume local is stored in zero page.
        Output.WriteLine($"    TYA");
        Output.WriteLine($"    CLC");
        Output.WriteLine($"    ADC #<{GetLocalVariableOffsetAddress(local)}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #0");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteLdsfld(EcmaField field)
    {
        WritePushFromMemory(GetStaticFieldName(field), field.Type.Size);
    }

    public override void WriteLdstr(string name)
    {
        Output.WriteLine($"    LDA #<{name}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
        Output.WriteLine($"    LDA #>{name}");
        Output.WriteLine($"    STA 0,X");
        Output.WriteLine($"    INX");
    }

    public override void WriteNewobj(EcmaMethod caller, EcmaMethod constructor, EcmaMethod allocMethod)
    {
        WritePushFrame(caller);

        // Call alloc method with size and vtablePtr parameters.
        {
            Span<byte> bytes = stackalloc byte[PointerSize];
            BinaryPrimitives.WriteUInt16LittleEndian(bytes, (ushort)constructor.DeclaringType.InstanceSize);
            for (var i = 0; i < PointerSize; i++)
            {
                Output.WriteLine($"    LDA #${bytes[i]:X2}");
                Output.WriteLine($"    STA {ArgsLabel}+{i},Y");
            }

            var vtableName = Vtable.GetName(constructor.DeclaringType);
            Output.WriteLine($"    LDA #<{vtableName}");
            Output.WriteLine($"    STA {ArgsLabel}+{PointerSize}+0,Y");
            Output.WriteLine($"    LDA #>{vtableName}");
            Output.WriteLine($"    STA {ArgsLabel}+{PointerSize}+1,Y");
        }
        Output.WriteLine($"    JSR {allocMethod.UniqueName}");

        // Current top of stack is address of memory allocated by alloc method.
        // We save it to the hardware stack, because this will be the result of newobj.
        // We also want to copy it into args as the first argument to the constructor.
        for (var i = PointerSize - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {ArgsLabel}+{i},Y");
            Output.WriteLine($"    PHA");
        }

        // Push constructor args (not including "this") to stack.
        WritePopToFrame(PointerSize, constructor.ParametersSize - PointerSize);

        // Call constructor.
        Output.WriteLine($"    JSR {constructor.UniqueName}");

        // Restore the address of the new object to the top of the stack.
        for (var i = 0; i < PointerSize; i++)
        {
            Output.WriteLine($"    PLA");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }

        WritePopFrame(caller);
    }

    public override void WriteRet()
    {
        Output.WriteLine("    RTS");
    }

    public override void WriteStfld(EcmaField field)
    {
        WriteStoreIndirect(field.Type, field.Offset);
    }

    public override void WriteStind(TypeDescription type)
    {
        WriteStoreIndirect(type, 0);
    }

    public override void WriteStloc(LocalVariable local)
    {
        WritePopToFrame(local.Parent.ParametersSize + local.Offset, local.Type.Size);
    }

    public override void WriteStsfld(EcmaField field)
    {
        WritePopToMemory(GetStaticFieldName(field), field.Type.Size);
    }

    private void WriteStoreIndirect(TypeDescription type, int destinationOffset)
    {
        // Value is at top of stack.
        // Underneath that is address of object.

        var addressLo = (byte)(0 - type.Size - PointerSize);
        var addressHi = (byte)(0 - type.Size - PointerSize + 1);

        Output.WriteLine($"    LDA ${addressLo:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA {ScratchLabel}+0");
        Output.WriteLine($"    LDA ${addressHi:X2},X ; Subtract value size + pointer size from current stack pointer");
        Output.WriteLine($"    STA {ScratchLabel}+1");

        WritePushY();

        for (var i = type.Size - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    LDY #{destinationOffset + i}");
            Output.WriteLine($"    STA ({ScratchLabel}),Y");
        }

        WritePopY();

        for (var i = 0; i < PointerSize; i++)
        {
            Output.WriteLine($"    DEX");
        }
    }

    private void WritePushFromMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = 0; i < sizeInBytes; i++)
        {
            Output.WriteLine($"    LDA {baseAddress}+{i}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    private void WritePushFromFrame(int offset, int sizeInBytes)
    {
        for (var i = 0; i < sizeInBytes; i++)
        {
            Output.WriteLine($"    LDA {ArgsLabel}+{offset}+{i},Y");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    protected void WritePushConstant(ReadOnlySpan<byte> bytes)
    {
        foreach (byte value in bytes)
        {
            Output.WriteLine($"    LDA #{value}");
            Output.WriteLine($"    STA 0,X");
            Output.WriteLine($"    INX");
        }
    }

    private void WritePopToMemory(string baseAddress, int sizeInBytes)
    {
        for (var i = sizeInBytes - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {baseAddress}+{i}");
        }
    }

    private void WritePopToFrame(int offset, int sizeInBytes)
    {
        for (var i = sizeInBytes - 1; i >= 0; i--)
        {
            Output.WriteLine($"    DEX");
            Output.WriteLine($"    LDA 0,X");
            Output.WriteLine($"    STA {ArgsLabel}+{offset}+{i},Y");
        }
    }

    protected void WritePushY()
    {
        Output.WriteLine("    TYA");
        Output.WriteLine("    PHA");
    }

    protected void WritePopY()
    {
        Output.WriteLine("    PLA");
        Output.WriteLine("    TAY");
    }

    private void WritePushFrame(EcmaMethod currentMethod)
    {
        var frameSize = currentMethod.FrameSize;

        if (frameSize == 0)
        {
            return;
        }

        Output.WriteLine($"    TYA ; Push frame");
        Output.WriteLine($"    CLC");
        Output.WriteLine($"    ADC #{frameSize}");
        Output.WriteLine($"    TAY");
    }

    private void WritePopFrame(EcmaMethod currentMethod)
    {
        var frameSize = currentMethod.FrameSize;

        if (frameSize == 0)
        {
            return;
        }

        // Decrement Y for new frame.
        Output.WriteLine($"    TYA ; Pop frame");
        Output.WriteLine($"    SEC");
        Output.WriteLine($"    SBC #{frameSize}");
        Output.WriteLine($"    TAY");
    }

    // Locals are stored immediately above args.
    private static string GetLocalVariableOffsetAddress(LocalVariable local) => 
        $"{ArgsLabel}+{local.Parent.ParametersSize + local.Offset}";

    private static string GetStaticFieldName(EcmaField field) => $"{field.Owner.EncodedName}_{field.Name}";
}
